{% capture body %}
class Resolver extends __SCOPED_RESOLVER<{{registration.service.accessorDeclaration}}> {
    doResolve(serviceProvider: __SERVICE_PROVIDER): {{registration.service.accessorDeclaration}} {
        const ctor: __CTOR<{{ registration.instance.accessorDeclaration }}> = {{ registration.instance.instanceTypeDefinition }};
        const ctorArgs: any[] = [];
    {%- capture dependencies -%}
       {%- for ctorSymbol in registration.instance.constructorArgs -%}
           {%- capture ctorServiceStatement -%}
               {%- if ctorSymbol.isCollection == true -%}
       ctorArgs.push(serviceProvider.resolveMany({{ ctorSymbol.symbolDescriptor | toSymbolPath }}));
                   {%- else -%}
       ctorArgs.push(serviceProvider.resolveOne({{ ctorSymbol.symbolDescriptor | toSymbolPath }}));
                   {%- endif -%}
           {% endcapture %}
        {{ ctorServiceStatement }}
       {%- endfor -%}
    {% endcapture -%}
        {{ dependencies }}
        return new ctor(...ctorArgs);
    }
}

export function register(resolvers: Map<symbol, __RESOLVER[]>) {
    const symbol = {{ registration.service.symbolDescriptor | toSymbolPath }};
    let symbolResolvers = resolvers.get(symbol);
    if (!symbolResolvers) {
        symbolResolvers = [];
        resolvers.set(symbol, symbolResolvers);
    }

    symbolResolvers.push(new Resolver());
}
{%- endcapture -%}

{%- for import in registration.imports -%}
    {{ import | toImport: outputDir }}
{% endfor %}

{%- if registration.includeAutoGeneratedSymbols -%}
import { TYPES as __SERVICE_TYPE_SYMBOLS } from './types.generated';
{% endif %}
import { ServiceProvider as __SERVICE_PROVIDER } from 'pileuple/api/serviceProvider';
import { {{ registration.scope }}ServiceResolver as __SCOPED_RESOLVER, InstanceConstructor as __CTOR, ServiceResolver as __RESOLVER } from 'pileuple/api/serviceResolver';
{{ body }}