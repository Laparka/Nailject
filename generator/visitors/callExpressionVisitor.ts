import { NodeVisitorBase } from './nodeVisitor';
import { CallExpression, Node, SyntaxKind } from 'typescript';
import {
  CodeAccessor,
  GeneratorContext,
  InstanceDescriptor,
  RegistrationDescriptor,
  ServiceDescriptor,
  SymbolDescriptor
} from '../generatorContext';
import { LifetimeScope } from '../../api/containerBuilder';
import { assignAccessorImport } from '../utils';

export default class CallExpressionVisitor extends NodeVisitorBase<CallExpression> {
  canVisit(node: Node): boolean {
    return node.kind === SyntaxKind.CallExpression;
  }

  doVisit(node: CallExpression, context: GeneratorContext): void {
    if (node.arguments.length > 1 || !node.typeArguments || node.typeArguments.length !== 2) {
      return;
    }

    const methodCallAccessor = this.visitNext(node.expression, context) as CodeAccessor;
    if (!methodCallAccessor) {
      return;
    }

    const instanceName = methodCallAccessor.name;
    if (instanceName !== context.instanceName) {
      return;
    }

    if (!methodCallAccessor.child) {
      return;
    }

    let scope: LifetimeScope;
    switch (methodCallAccessor.child.name) {
      case 'addSingleton': {
        scope = 'Singleton';
        break;
      }

      case 'addTransient': {
        scope = 'Transient';
        break;
      }

      default: {
        throw new Error(`Not supported registration-method ${methodCallAccessor.child.name}`);
      }
    }

    const serviceTypeAccessor = this.visitNext(node.typeArguments[0], context) as CodeAccessor;
    if (!serviceTypeAccessor || !serviceTypeAccessor.name) {
      throw Error(`No service type argument is defined for the ${methodCallAccessor.child.name}-method`)
    }

    const instanceTypeAccessor = this.visitNext(node.typeArguments[1], context) as CodeAccessor;
    if (!instanceTypeAccessor || !instanceTypeAccessor.name) {
      throw Error(`No instance type argument is defined for the ${methodCallAccessor.child.name}-method`)
    }

    const serviceImport = assignAccessorImport(serviceTypeAccessor, context.imports);
    if (!serviceImport) {
      throw Error(`Failed to find the service type in imports`);
    }

    let symbolDescriptor: SymbolDescriptor | undefined;

    if (node.arguments.length === 1) {
      const argumentTypeAccessor = this.visitNext(node.arguments[0], context) as CodeAccessor;
      if (!argumentTypeAccessor) {
        throw Error(`Failed to parse the constructor argument type of ${instanceTypeAccessor.name}`)
      }

      const symbolTypeImport = assignAccessorImport(argumentTypeAccessor, context.imports);
      if (!symbolTypeImport) {
        throw Error(`Failed to find the import type of the ${argumentTypeAccessor.name} constructor argument`);
      }

      symbolDescriptor = {
        accessor: argumentTypeAccessor,
        autoGenerated: false
      };
    }

    if (!symbolDescriptor) {
      symbolDescriptor = {
        autoGenerated: true,
        accessor: serviceTypeAccessor
      };
    }

    const serviceDescriptor: ServiceDescriptor = {
      symbolDescriptor: symbolDescriptor,
      accessor: serviceTypeAccessor
    };

    const instanceTypeImport = assignAccessorImport(instanceTypeAccessor, context.imports);
    if (!instanceTypeImport) {
      throw Error(`Failed to find the instance type in imports`);
    }

    const instanceDescriptor: InstanceDescriptor = {
      accessor: instanceTypeAccessor,
      constructorArgs: []
    };

    const registrationDescriptor: RegistrationDescriptor = {
      scope: scope,
      instance: instanceDescriptor,
      service: serviceDescriptor
    };

    context.registrations.push(registrationDescriptor);
  }
}