import RegistrationsParser from './generator/registrationsParser';
import { GeneratorParameters, RegistrationSymbol } from './generator/generatorContext';
import { Liquid } from 'liquidjs'
import * as path from 'path';
import { toImportFilter, toSymbolPath } from './generator/templates/filters';
import { CodeWriter } from './generator/services/codeWriter';

const templateDir = path.join(__dirname, 'generator', 'templates');
const resolverTemplatePath = path.join(templateDir, 'resolver.liquid');
const symbolTypesTemplatePath = path.join(templateDir, 'types.liquid');
const serviceProviderTemplatePath = path.join(templateDir, 'serviceProvider.liquid');

const liquid = new Liquid();
liquid.registerFilter('toImport', toImportFilter);
liquid.registerFilter('toSymbolPath', toSymbolPath);

const parser = new RegistrationsParser();
export class IoCGenerator {
  private readonly _writer: CodeWriter;
  constructor(writer: CodeWriter) {
    this._writer = writer;
  }

  generate(parameters: GeneratorParameters): string[] {
    console.log(JSON.stringify(parameters));
    if (!parameters || !parameters.registrationFilePath) {
      throw Error(`The source registration file path is required`);
    }

    if (!parameters.registrationClassName) {
      throw Error(`The source registration class name is required`);
    }

    if (!parameters.outputDirectory) {
      throw Error(`The output directory path is required`)
    }

    const registrations = parser.parse(parameters);
    const allSymbols: RegistrationSymbol[] = [];
    const namespaces: string[] = [];
    const resolvers: string[] = [];
    for (const r of registrations) {
      const resolverName = [r.instance!.displayName, r.service.displayName].join('Of') + `${r.scope}ServiceResolver`;
      const outputFile = resolverName[0].toLowerCase() + resolverName.substring(1, resolverName.length);
      this.renderToOutput(parameters, `${outputFile}.ts`, resolverTemplatePath,{
        registration: r,
        outputDir: parameters.outputDirectory
      });
      const symbol = r.service.symbolDescriptor;
      if (symbol.autoGenerated) {
        if (allSymbols.findIndex(s => s.symbolId === symbol.symbolId && s.symbolNamespace === symbol.symbolNamespace) === -1) {
          allSymbols.push(symbol);
        }

        if (namespaces.findIndex(n => n === symbol.symbolNamespace) === -1) {
          namespaces.push(symbol.symbolNamespace);
        }
      }

      resolvers.push(outputFile);
    }

    this.renderToOutput(parameters, "types.generated.ts", symbolTypesTemplatePath, {namespaces, symbols: allSymbols});
    this.renderToOutput(parameters, "index.ts", serviceProviderTemplatePath, { resolvers: resolvers});
    return resolvers;
  }

  private renderToOutput(parameters: GeneratorParameters, outputFile: string, templatePath: string, renderModel: any) {
    const filePath = path.join(parameters.outputDirectory, outputFile);
    const content = liquid.renderFileSync(templatePath, renderModel);
    this._writer.write(filePath, content);
  }
}